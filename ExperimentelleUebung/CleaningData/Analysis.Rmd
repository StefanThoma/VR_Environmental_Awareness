---
title: "Analyse"
author: "Stefan P. Thoma"
date: "1/30/2020"
output: html_document
---

# Setup

```{r setup, include=FALSE}
set.seed(198742)
knitr::opts_chunk$set(echo = TRUE)
if (!require("pacman")) install.packages("pacman")
p_load(tidyverse, ggplot2, lme4, ggthemes, lmerTest)
```

# Load Data
```{r}
data <- read_csv("Exp_Data.csv")
# show the first 6 rows of the data
head(data)
```
We can see that each Participant has two entries; one for each timepoint of testing. 
The data is in the so called "long"-format.
This is useful for analysis and visualisation, but it can be confusing that some entries seem to be duplicated. 
This is simply because values which are captured at only one timepoint (e.g. gender) are also assigned to the entry of the other time point. 


Although the data has been cleaned, it is not yet fully processed. 
For example, some items were reverse coded.
If we want to calculate the average of a test, the items need to be coded all the same way. 
Otherwise, the averages do not make sense. 

# Recode Items
## Define Items to recode

We can actually look at the data to see which items are reversely coded.
This should be done only as a confirmation. 
The decision should be made based on the papers introducing the respective scale.
Also, it should be fairly obvious which are reversely coded when reading the questions.

```{r}
# define items to be recoded (as defined in the papers)
nep_reorder <- paste("nep", c(2, 4, 6, 8, 10, 12, 14), sep = "")
nr_reorder <- paste("nr", c(2, 3, 10, 11, 13, 14, 15, 18), sep = "")
# in the ccs, they are all coded the same way. 
ipq_reorder <- paste("ipq", c(3, 9, 11), sep = "") 
sod_reorder <- paste("sod", c( 2, 4, 5, 6, 7, 8), sep = "_")
```

Look what data looks like regarding coding.
Checked with a principal component analysis.
```{r, eval = FALSE}
psych::pca(r = data %>% select(starts_with("nep")))
psych::pca(r = data %>% select(starts_with("nr")))
psych::pca(r = data %>% select(starts_with("ccs")))
psych::pca(r = data %>% select(starts_with("ipq")))
psych::pca(r = data %>% select(starts_with("sod"))) # looks like sod_1 is kinda different! 
# But according to theory, this is correctly coded. 
```

Check on what scale the items are coded:
```{r, EVAL = FALSE}
range(data %>% select(starts_with("nep"))) # 1 to 5 so 1 becomes 5, 2 becomes 4, etc...
range(data %>% select(starts_with("nr"))) # 1 to 5 so 1 becomes 5, 2 becomes 4, etc...
range(data %>% select(starts_with("ccs"))) # 1 to 5 so 1 becomes 5, 2 becomes 4, etc...
summary(data %>% select(starts_with("ipq"))) # 1 to 7 so 1 becomes 7, 2 becomes 6, etc...
summary(data %>% select(starts_with("sod"))) # 1 to 7  so 1 becomes 7, 2 becomes 6, etc...
```

## helping function
```{r recode}
umpolen7 <- function(items, dat){
  for(i in items){
    
    dat[[i]] <- ifelse(dat[[i]] == 1, 7, 
                       ifelse(dat[[i]] == 2, 6, 
                              ifelse(dat[[i]] == 3, 5, 
                                     ifelse(dat[[i]] == 4, 4, 
                                            ifelse(dat[[i]] == 5, 3, 
                                                   ifelse(dat[[i]] == 6, 2, 
                                                          ifelse(dat[[i]] == 7, 1, NA)))))))
    
  }
  return(dat)
}

umpolen5 <- function(items, dat){
  for(i in items){
    
    dat[[i]] <- ifelse(dat[[i]] == 1, 5, 
                       ifelse(dat[[i]] == 2, 4, 
                              ifelse(dat[[i]] == 3, 3, 
                                     ifelse(dat[[i]] == 4, 2, 
                                            ifelse(dat[[i]] == 5, 1, NA)))))
  }
  return(dat)
}


```


## finally recode
```{r}
data_clean <- umpolen7(c(sod_reorder, ipq_reorder), dat = data)

data_clean <- umpolen5(c(nep_reorder, nr_reorder), dat = data_clean)
```
## did it work?
```{r}
psych::pca(r = data_clean %>% select(starts_with("nep")))
psych::pca(r = data_clean %>% select(starts_with("nr")))
psych::pca(r = data_clean %>% select(starts_with("ccs")))
psych::pca(r = data_clean %>% select(starts_with("ipq")))
psych::pca(r = data_clean %>% select(starts_with("sod")))
```
(Yes of course... ;) )
Again,  it becomes apparent that sod_1 is weird. Go and check the question and think why this could be. 
Should we still keep it in the analysis?

# Calculate score means
I just calculate it for one of the scores. The rest you have to do yourself. 

```{r  score means}
data_clean$nep <- rowMeans(data_clean %>% select(starts_with("nep")))
data_clean$nr <- rowMeans(data_clean %>% select(starts_with("nr")))
data_clean$ccs <- rowMeans(data_clean %>% select(starts_with("ccs")))
data_clean$ipq <- rowMeans(data_clean %>% select(starts_with("ipq")))
data_clean$sod <- rowMeans(data_clean %>% select(starts_with("sod")))
```

# Analysis


## Try your way:
### First visualise (this is just for nep)

```{r}
ggplot(data = data_clean, aes(x = time, y = nep, color = condition)) + 
  geom_line(aes(group = id, color = condition), alpha = .2) +
  geom_smooth(aes(x = time, y = nep), inherit.aes = T, method = "lm", se = F)+
  geom_jitter(width = .05, alpha = .2) +
  ggthemes::theme_tufte()
```
```{r boxplots nep}
ggplot(data = data_clean, aes(x = interaction(time, condition), y = nep, color = condition)) +
  geom_violin(draw_quantiles = .5) + 
  geom_jitter(width = .2) + 
  geom_line(aes(group = id), alpha = .2)+
  theme_tufte()
```

or plot differences
```{r}
# calculate differences
data_clean <- data_clean %>% group_by(id) %>%
  mutate(nep_diff = nep[time == 2] - nep[time == 1]) %>%
  ungroup

# differences: positive values stand for increased nep and negative values stand for decreased values

# plot
ggplot(data = data_clean %>% filter(time==1), aes(x = condition, y = nep_diff, color = condition)) + 
  geom_violin(draw_quantiles = .5) + 
  geom_jitter(width = .2)+
  theme_tufte()



```


### with t.test

```{r}
# two sample t-test
t.test(formula = nep ~ time, data =data_clean)

# underestimates the effect, as structure of the data is not being taken into account.
```
We have not two independent groups, but two dependent ones.
```{r}
t.test(formula = nep ~ time, data =data_clean, paired = TRUE)
mean(data_clean$nep_diff)

# or with aov
nep_aov_model <- aov(nep~time + Error(id/time), data = data_clean)
summary(nep_aov_model)
```
This is valid. But this still neglects the experimental structure 

Better use hierarchical model including all needed predictors

```{r hierarchical nep}
nep_model_null <- lmer(data = data_clean, formula = nep ~ 1 + (1|id))
nep_model_time <- lmer(data = data_clean, formula = nep ~ time + (1|id))
nep_model_timeCondition <- lmer(data = data_clean, formula = nep ~ time + condition + (1|id))
nep_model_full <- lmer(data = data_clean, formula = nep ~ time*condition + (1|id))
anova(nep_model_null, nep_model_time, nep_model_timeCondition, nep_model_full)
ranova(nep_model_null)
```








